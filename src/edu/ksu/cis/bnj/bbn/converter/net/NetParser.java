/* Generated By:JJTree&JavaCC: Do not edit this line. NetParser.java */
package edu.ksu.cis.bnj.bbn.converter.net;

/*
 *
 * This file is part of Bayesian Network for Java (BNJ).
 *
 * BNJ is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * BNJ is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with BNJ in LICENSE.txt file; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
 *
 */

/**
 * @author: Roby Joehanes
 */

import edu.ksu.cis.bnj.bbn.*;
import edu.ksu.cis.bnj.bbn.converter.Converter;
import edu.ksu.cis.bnj.bbn.converter.ConverterOutputStream;
import edu.ksu.cis.kdd.util.Settings;
import edu.ksu.cis.kdd.util.graph.Edge;
import edu.ksu.cis.kdd.util.parser.ast.*;

import java.io.*;
import java.util.*;

public class NetParser implements /*@bgen(jjtree)*/ NetParserTreeConstants, Converter, NetParserConstants {/*@bgen(jjtree)*/
    protected JJTNetParserState jjtree = new JJTNetParserState();
    protected Hashtable nodeCache = new Hashtable();
    protected Hashtable edgeCache = new Hashtable();
    protected Hashtable valueCache = new Hashtable();

    public static final int FORMATv6_0 = 0;
    public static final int FORMATv5_7 = 1;
    public static final int FORMAT_DEFAULT = 0;

    public static int saveFormat = FORMAT_DEFAULT;
    protected static String ln = System.getProperty("line.separator"); // $NON-NLS-1$

    public NetParser() {
        // Do nothing, just to provide a stub
    }

    public BBNGraph load(InputStream r) throws ParseException {
        NetParser p = new NetParser(r);
        BBNGraph g = p.CompilationUnit();
        System.gc();
        return g;
    }

    public void save(OutputStream os, BBNGraph graph) {
        Writer stream = new OutputStreamWriter(os);
        try {
            switch (saveFormat) {
                case FORMATv6_0:
                    String graphName = graph.getName();
                    if (os instanceof ConverterOutputStream) { // This bug fix is courtesy of Jan-Diederik van Wees
                        graphName = ((ConverterOutputStream) os).getFileName();
                        int fromPos = graphName.lastIndexOf(File.separator);
                        int toPos = graphName.lastIndexOf("."); // $NON-NLS-1$
                        if (fromPos > -1 && toPos > -1 && fromPos < toPos)
                            graphName = graphName.substring(fromPos + 1, toPos); // $NON-NLS-1$
                        else
                            graphName = graph.getName();
                    }
                    stream.write("class " + graphName + " {  % you may need to change this network name to match the filename" + ln);
                    break; // $NON-NLS-1$ // $NON-NLS-2$
                case FORMATv5_7:
                    stream.write("net {" + ln);
                    break; // $NON-NLS-1$
                default:
                    throw new RuntimeException("Unknown save format value!");
            }

            // Write the graph property
            int filler = 1;
            String tab = ""; // $NON-NLS-1$
            Hashtable property = graph.getProperty();
            stream.write(saveProperty(property, filler));

            switch (saveFormat) {
                case FORMATv6_0:
                    stream.write(ln);
                    break;
                case FORMATv5_7:
                    stream.write("}" + ln + ln);
                    filler = 0;
                    break; // $NON-NLS-1$
                default:
                    throw new RuntimeException("Unknown save format value!");
            }

            // Cache
            Hashtable valueListTable = new Hashtable();
            Hashtable parentListTable = new Hashtable();
            Hashtable cpfTable = new Hashtable();
            LinkedList tempList;

            // Dumping out the nodes
            Set nodes = graph.getNodes(); // nodes shall never be null
            for (Iterator i = nodes.iterator(); i.hasNext();) {
                BBNNode node = (BBNNode) i.next();
                String nodeName = node.getLabel();

                List parents = node.getParents();
                if (parents != null && parents.size() > 0) {
                    tempList = new LinkedList();
                    tempList.addAll(parents);
                    parentListTable.put(nodeName, tempList);
                }

                Hashtable cpf = node.getCPF().getTable();
                if (cpf != null && cpf.size() > 0)
                    cpfTable.put(nodeName, cpf);

                stream.write(getFiller(filler));
                if (node.isDecision())
                    stream.write("decision "); // $NON-NLS-1$
                else if (node.isUtility())
                    stream.write("utility "); // $NON-NLS-1$
                else
                    stream.write("node "); // $NON-NLS-1$

                stream.write(nodeName + " {" + ln); // $NON-NLS-1$
                filler++;

                // the label, if any
                tab = getFiller(filler);
                String label = node.getLabel();
                if (label != null && !label.equals("")) { // $NON-NLS-1$
                    if (!label.startsWith("\"")) // $NON-NLS-1$
                        stream.write(tab + "label = \"" + label + "\";" + ln); // $NON-NLS-1$ // $NON-NLS-2$
                    else
                        stream.write(tab + "label = " + label + ";" + ln); // $NON-NLS-1$ // $NON-NLS-2$
                }

                // the values, if any (a.k.a. states)
                BBNValue values = node.getValues();
                if (values != null) // i.e. not a utility node
                {
                    if (values instanceof BBNDiscreteValue) {
                        BBNDiscreteValue dvals = (BBNDiscreteValue) values;
                        if (dvals.size() > 0) {
                            tempList = new LinkedList();
                            tempList.addAll(dvals);
                            valueListTable.put(nodeName, tempList);
                            stream.write(tab + "states = ("); // $NON-NLS-1$
                            for (Iterator vi = dvals.iterator(); vi.hasNext();) {
                                stream.write("\"" + vi.next() + "\""); // $NON-NLS-1$ // $NON-NLS-2$
                                if (vi.hasNext()) stream.write(" "); // $NON-NLS-1$
                            }
                            stream.write(");" + ln); // $NON-NLS-1$
                        }
                    } else {
                        throw new RuntimeException("Don't know how to handle continuous values yet. Vague Hugin documentation.");
                    }
                }

                // Save other properties as well
                stream.write(saveProperty(node.getProperty(), filler));

                filler--;
                stream.write(getFiller(filler) + "}" + ln + ln); // $NON-NLS-1$
            }

            // Dumping out the edges and the CPT/CPFs.
            // Aye sir, iterate through the node since we have cached things
            // in the first iteration.
            for (Iterator i = nodes.iterator(); i.hasNext();) {
                BBNNode node = (BBNNode) i.next();
                String nodeName = node.getLabel();
                LinkedList parents = (LinkedList) parentListTable.get(nodeName);
                LinkedList nodeNameList = new LinkedList();

                stream.write(getFiller(filler) + "potential (" + nodeName); // $NON-NLS-1$
                if (parents != null && parents.size() > 0) {
                    stream.write(" | "); // $NON-NLS-1$
                    for (Iterator pi = parents.iterator(); pi.hasNext();) {
                        BBNNode pNode = (BBNNode) pi.next();
                        String pName = pNode.getLabel();
                        if (!pNode.isUtility()) nodeNameList.add(pName);
                        stream.write(pName);
                        if (pi.hasNext()) stream.write(" "); // $NON-NLS-1$
                    }
                }
                stream.write(") {"); // $NON-NLS-1$

                if (!node.isUtility())
                    nodeNameList.add(nodeName);  // a cheat!! ;-)

                if (nodeNameList.size() > 0 && !node.isDecision()) {
                    filler++;
                    tab = getFiller(filler);
                    stream.write(ln + tab + "data = "); // $NON-NLS-1$
                    String cpfdata = saveCPT(valueListTable, (Hashtable) cpfTable.get(nodeName), nodeNameList, new Hashtable(), new StringBuffer(), tab + "        "); // $NON-NLS-1$

                    if (Settings.DEBUG)
                        System.out.println("%%DEBUG%%" + nodeName + " data = " + cpfdata); // $NON-NLS-1$ // $NON-NLS-2$

                    stream.write(cpfdata + ";" + ln); // $NON-NLS-1$
                    filler--;
                    stream.write(getFiller(filler));
                }

                stream.write("}" + ln + ln); // $NON-NLS-1$
            }
            if (saveFormat == FORMATv6_0) stream.write("}"); // $NON-NLS-1$
            stream.flush();
            stream.close();
        } catch (Exception e) {
            throw new RuntimeException(e);
        }
    }

    /**
     * Encode the flat-encoded CPF back into its nested String form.
     * Dunno about the continuous chance node... It will break
     *
     * @param valueListTable A table of node name -> its value. If get method returns null,
     *                       then it has no value (possibly a utility node).
     * @param cpf            The flat CPF we want to encode
     * @param nodes          The list of node names that has a role in the CPF encoding
     * @param curQuery       It is the Hashtable to form the query
     * @param buf            The string buffer for the output
     * @param filler         The string to pad the output (to beautify it)
     * @return String The encoded string
     */
    protected String saveCPT(Hashtable valueListTable, Hashtable cpf, LinkedList nodes, Hashtable curQuery, StringBuffer buf, String filler) {
        String nodeName = (String) nodes.removeFirst();
        buf.append("("); // $NON-NLS-1$

        List values = (List) valueListTable.get(nodeName);
        if (values == null)
            throw new RuntimeException("Bug! The node " + nodeName + " has no value (possibly a utility node) but included in cpt encoding!");

        for (Iterator i = values.iterator(); i.hasNext();) {
            Object val = i.next();
            curQuery.put(nodeName, val);

            if (nodes.size() > 0) {
                saveCPT(valueListTable, cpf, nodes, curQuery, buf, filler);
            } else {
                assert (nodes.size() == 0);
                val = cpf.get(curQuery);
                if (val == null)
                    throw new RuntimeException("Bug! The encoded query fails!");
                buf.append(val.toString());
            }

            if (i.hasNext()) buf.append(" "); // $NON-NLS-1$
        }

        nodes.addFirst(nodeName);
        curQuery.remove(nodeName);
        buf.append(")"); // $NON-NLS-1$
        if (nodes.size() == 1 && curQuery.size() > 0)
            buf.append("  % " + curQuery + ln); // $NON-NLS-1$
        if (curQuery.size() < 3)
            buf.append(ln + filler);

        // Beautify
        int max = curQuery.size() - 2;
        if (nodes.size() == 1)
            for (int i = 0; i < max; i++)
                buf.append(" "); // $NON-NLS-1$

        return buf.toString().trim();
    }

    protected String saveProperty(Hashtable property, int filler) {
        if (property == null || property.size() == 0) return ""; // $NON-NLS-1$
        StringBuffer buf = new StringBuffer();
        String tab = getFiller(filler);
        for (Enumeration e = property.keys(); e.hasMoreElements();) {
            Object key = e.nextElement();
            Object value = property.get(key);
            buf.append((tab + key).replace('.', '_') + " = "); // $NON-NLS-1$
            if (value instanceof List) {
                buf.append("("); // $NON-NLS-1$
                for (Iterator i = ((List) value).iterator(); i.hasNext();) {
                    Object item = i.next();
                    if (item instanceof Double) {
                        double num = ((Double) item).doubleValue();
                        String irnum = String.valueOf(Math.round(num));
                        double rnum = (new Double(irnum)).doubleValue();
                        if (num == rnum)
                            buf.append(irnum);
                        else
                            buf.append(String.valueOf(num));
                    } else {
                        buf.append("\"" + item + "\""); // $NON-NLS-1$ // $NON-NLS-2$
                    }
                    if (i.hasNext()) buf.append(" "); // $NON-NLS-1$
                }
                buf.append(");" + ln); // $NON-NLS-1$
            } else {
                buf.append(("\"" + value + "\";").replace('.', '_') + ln); // $NON-NLS-1$ // $NON-NLS-2$
            }
        }
        return buf.toString();
    }

    protected String getFiller(int n) {
        String tab = "     "; // $NON-NLS-1$
        StringBuffer buf = new StringBuffer();
        for (int i = 0; i < n; i++)
            buf.append(tab);
        return buf.toString();
    }

    public void initialize() {
    }

    protected BBNGraph processGraph(BBNGraph g) {
        if (g == null)
            throw new RuntimeException("Bug! Graph is null at NetParser.processGraph!");

        // Building nodes and edges
        g.addNodes(nodeCache.values());

        // Iterate through the edges to construct the edges and to fill in the CPT.
        for (Enumeration e = edgeCache.keys(); e.hasMoreElements();) {
            String nodeName = (String) e.nextElement();
            Object[] wrapper = (Object[]) edgeCache.get(nodeName);
            List parents = (List) wrapper[0];
            LinkedList data = (LinkedList) wrapper[1];

            BBNNode node = (BBNNode) nodeCache.get(nodeName);
            if (node == null)
                throw new RuntimeException("Cannot resolve node " + nodeName);

            LinkedList valueList = new LinkedList();

            for (Iterator i = parents.iterator(); i.hasNext();) {
                String parentName = (String) i.next();
                BBNNode parentNode = (BBNNode) nodeCache.get(parentName);
                if (parentNode == null)
                    throw new RuntimeException("Cannot resolve node " + parentName);
                if (parentNode.isUtility())
                    throw new RuntimeException("Utility nodes can never be parent nodes!");
                Edge edge = new Edge(parentNode, node);
                try {
                    g.addEdge(edge);
                } catch (Exception ex) {
                    throw new RuntimeException(ex);
                }

                Object parentValue = valueCache.get(parentName);
                if (parentValue != null)
                    valueList.add(new Object[]{parentName, parentValue});
            }

            // if it's a decision node, don't bother constructing a CPF
            if (node.isDecision()) continue;

            Object nodeValue = valueCache.get(nodeName);
            if (nodeValue != null) valueList.add(new Object[]{nodeName, nodeValue});

            if (valueList.size() > 0) {
                Hashtable cpf = formatCPF(valueList, data, new Hashtable(), new Hashtable());
                node.setCPF(cpf);
            }
        }

        return g;
    }

    /**
     * Reformat the list of lists into CPF
     *
     * @param valueList  Basically list of node name and its value list
     * @param data       The data in multiply nested lists
     * @param queryValue BBNQuery entry to be inputted
     * @param input      the resulting CPF, passed recursively while building
     * @return Hashtable the CPF
     */
    protected Hashtable formatCPF(LinkedList valueList, LinkedList data, Hashtable queryValue, Hashtable input) {
        Object[] wrapper = (Object[]) valueList.removeFirst();
        String name = (String) wrapper[0];
        List values = (List) wrapper[1];

        if (values.size() != data.size()) {
            throw new RuntimeException("CPT cardinality doesn't match!");
        }

        for (Iterator i = values.iterator(); i.hasNext();) {
            Object value = i.next();
            queryValue.put(name, value);
            if (valueList.size() > 0) {
                LinkedList curData = (LinkedList) data.removeFirst();
                input.putAll(formatCPF(valueList, curData, queryValue, input));
            } else {
                Hashtable query = (Hashtable) queryValue.clone();
                Object probValue = data.removeFirst();
                if (probValue instanceof Double)
                    probValue = new BBNConstant(((Double) probValue).doubleValue());
                input.put(query, probValue);
            }
        }
        valueList.addFirst(wrapper);
        return input;
    }

    /**
     * This is to reset cache. Useful later if we decided to support OOBN.
     */
    protected void resetCache() {
        nodeCache = new Hashtable();
        edgeCache = new Hashtable();
        valueCache = new Hashtable();
    }

    public static void help() {
        System.out.println("Hugin .net Parser:  Usage is one of:");
        System.out.println("         java NetParser < inputfile");
        System.out.println("OR");
        System.out.println("         java NetParser inputfile");
    }

    public static void main(String[] args) {
        if (args.length > 1) {
            help();
            return;
        }
        try {
            if (args.length == 0) {
                System.out.println("Hugin .net Parser:  Reading from standard input");
                new NetParser().load(System.in);
            } else if (args.length == 1) {
                System.out.println("Hugin .net Parser:  Reading from file " + args[0]);
                new NetParser().load(new FileInputStream(args[0]));
            }
        } catch (Exception e) {
            System.out.println(e.getMessage());
            System.out.println("Error!");
        }
    }

    /**
     * *******************************************
     * THE HUGIN NET LANGUAGE GRAMMAR STARTS HERE *
     * ********************************************
     */


    /*
       If we handle OOBN, the return value must be changed into a list or a set.
       Then we have to change the loader interface quite a bit.
       OR...
       Make a wrapper class. Either way is ok.

       But it's not ready yet, since we have to make some interconnection between
       graph object. Probably we can make BBNGraph into a wrapper class that can
       connect to another node in another graph.
    */
    final public BBNGraph CompilationUnit() throws ParseException {
        BBNGraph graph = null;
        switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
            case CLASS:
                graph = Formatv6_0();
                break;
            case NET:
                graph = Formatv5_7();
                break;
            default:
                jj_la1[0] = jj_gen;
                jj_consume_token(-1);
                throw new ParseException();
        }
        {
            if (true) return processGraph(graph);
        }
        throw new Error("Missing return statement in function");
    }

    final public BBNGraph Formatv6_0() throws ParseException {
        BBNGraph graph = new BBNGraph();
        Token t = null;
        Hashtable property;
        jj_consume_token(CLASS);
        t = jj_consume_token(IDENTIFIER);
        graph.setName(t.image);
        jj_consume_token(LBRACE);
        property = GraphProperties();
        label_1:
        while (true) {
            switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
                case NODE:
                case CONTINUOUS:
                case DISCRETE:
                case UTILITY:
                case DECISION:
                    Node();
                    break;
                case POTENTIAL:
                    Edge();
                    break;
                default:
                    jj_la1[1] = jj_gen;
                    jj_consume_token(-1);
                    throw new ParseException();
            }
            switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
                case NODE:
                case POTENTIAL:
                case CONTINUOUS:
                case DISCRETE:
                case UTILITY:
                case DECISION:
                    ;
                    break;
                default:
                    jj_la1[2] = jj_gen;
                    break label_1;
            }
        }
        jj_consume_token(RBRACE);
        {
            if (true) return graph;
        }
        throw new Error("Missing return statement in function");
    }

    final public BBNGraph Formatv5_7() throws ParseException {
        BBNGraph graph = new BBNGraph();
        Token t = null;
        Hashtable property;
        jj_consume_token(NET);
        jj_consume_token(LBRACE);
        property = GraphProperties();
        jj_consume_token(RBRACE);
        label_2:
        while (true) {
            switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
                case NODE:
                case CONTINUOUS:
                case DISCRETE:
                case UTILITY:
                case DECISION:
                    Node();
                    break;
                case POTENTIAL:
                    Edge();
                    break;
                default:
                    jj_la1[3] = jj_gen;
                    jj_consume_token(-1);
                    throw new ParseException();
            }
            switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
                case NODE:
                case POTENTIAL:
                case CONTINUOUS:
                case DISCRETE:
                case UTILITY:
                case DECISION:
                    ;
                    break;
                default:
                    jj_la1[4] = jj_gen;
                    break label_2;
            }
        }
        graph.setProperty(property);
        {
            if (true) return graph;
        }
        throw new Error("Missing return statement in function");
    }

    final public Hashtable GraphProperties() throws ParseException {
        Token t;
        LinkedList list;
        String contents;
        Hashtable property = new Hashtable();
        label_3:
        while (true) {
            switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
                case INPUTS:
                case OUTPUTS:
                case NODE_SIZE:
                case IDENTIFIER:
                    ;
                    break;
                default:
                    jj_la1[5] = jj_gen;
                    break label_3;
            }
            switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
                case INPUTS:
                    jj_consume_token(INPUTS);
                    jj_consume_token(ASSIGN);
                    list = StringList();
                    if (property.get("inputs") != null) // $NON-NLS-1$
                    {
                        if (true) throw new RuntimeException("inputs is declared more than once!");
                    }
                    property.put("inputs", list);
                    break;
                case OUTPUTS:
                    jj_consume_token(OUTPUTS);
                    jj_consume_token(ASSIGN);
                    list = StringList();
                    if (property.get("outputs") != null) // $NON-NLS-1$
                    {
                        if (true) throw new RuntimeException("outputs is declared more than once!");
                    }
                    property.put("outputs", list);
                    break;
                case NODE_SIZE:
                    jj_consume_token(NODE_SIZE);
                    jj_consume_token(ASSIGN);
                    list = NumberList();
                    if (property.get("node_size") != null) // $NON-NLS-1$
                    {
                        if (true) throw new RuntimeException("node_size is declared more than once!");
                    }
                    property.put("node_size", list);
                    break;
                case IDENTIFIER:
                    t = jj_consume_token(IDENTIFIER);
                    jj_consume_token(ASSIGN);
                    contents = StringLiteral();
                    if (property.get(t.image) != null) {
                        if (true) throw new RuntimeException(t.image + " is declared more than once!");
                    }
                    property.put(t.image, contents);
                    break;
                default:
                    jj_la1[6] = jj_gen;
                    jj_consume_token(-1);
                    throw new ParseException();
            }
            jj_consume_token(SEMICOLON);
        }
        {
            if (true) return property;
        }
        throw new Error("Missing return statement in function");
    }

    final public void Node() throws ParseException {
        BBNNode node = new BBNNode();
        Token t = null;
        LinkedList list = null;
        String contents, label = null, name;
        Hashtable property = new Hashtable();
        boolean isContinuous = false;
        switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
            case CONTINUOUS:
            case DISCRETE:
                switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
                    case CONTINUOUS:
                        jj_consume_token(CONTINUOUS);
                        isContinuous = true;
                        break;
                    case DISCRETE:
                        jj_consume_token(DISCRETE);
                        break;
                    default:
                        jj_la1[7] = jj_gen;
                        jj_consume_token(-1);
                        throw new ParseException();
                }
                break;
            default:
                jj_la1[8] = jj_gen;
                ;
        }
        switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
            case NODE:
                jj_consume_token(NODE);
                break;
            case DECISION:
                jj_consume_token(DECISION);
                node.setType(BBNNode.DECISION);
                break;
            case UTILITY:
                jj_consume_token(UTILITY);
                node.setType(BBNNode.UTILITY);
                break;
            default:
                jj_la1[9] = jj_gen;
                jj_consume_token(-1);
                throw new ParseException();
        }
        t = jj_consume_token(IDENTIFIER);
        jj_consume_token(LBRACE);
        name = t.image;
        node.setName(name);
        label_4:
        while (true) {
            switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
                case LABEL:
                    jj_consume_token(LABEL);
                    jj_consume_token(ASSIGN);
                    label = StringLiteral();
                    if (label != null && label.trim().length() > 0) node.setLabel(label);
                    break;
                case POSITION:
                    jj_consume_token(POSITION);
                    jj_consume_token(ASSIGN);
                    list = NumberList();
                    if (property.get("position") != null) // $NON-NLS-1$
                    {
                        if (true) throw new RuntimeException("position is declared more than once for node '" + name + "'!");
                    }
                    property.put("position", list);
                    break;
                case SUBTYPE:
                    jj_consume_token(SUBTYPE);
                    jj_consume_token(ASSIGN);
                    t = jj_consume_token(IDENTIFIER);
                    if (property.get("subtype") != null) // $NON-NLS-1$
                    {
                        if (true) throw new RuntimeException("subtype is declared more than once for node '" + name + "'!");
                    }
                    property.put("subtype", t.image);
                    break;
                case STATES:
                    jj_consume_token(STATES);
                    jj_consume_token(ASSIGN);
                    list = StringList();
                    if (isContinuous) {
                        if (true) throw new RuntimeException("Continuous nodes are not supposed to have node values " + name);
                    }
                    if (node.isUtility()) {
                        if (true) throw new RuntimeException("Utility nodes are not supposed to have node values " + name);
                    }
                    if (valueCache.get(name) != null) {
                        if (true) throw new RuntimeException("Duplicated declaration of value states for node " + name);
                    }
                    valueCache.put(name, list);
                    node.setValues(new BBNDiscreteValue(list));
                    break;
                case IDENTIFIER:
                    t = jj_consume_token(IDENTIFIER);
                    jj_consume_token(ASSIGN);
                    contents = StringLiteral();
                    if (property.get(t.image) != null) {
                        if (true) throw new RuntimeException(t.image + " is declared more than once!");
                    }
                    property.put(t.image, contents);
                    break;
                default:
                    jj_la1[10] = jj_gen;
                    jj_consume_token(-1);
                    throw new ParseException();
            }
            jj_consume_token(SEMICOLON);
            switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
                case LABEL:
                case POSITION:
                case STATES:
                case SUBTYPE:
                case IDENTIFIER:
                    ;
                    break;
                default:
                    jj_la1[11] = jj_gen;
                    break label_4;
            }
        }
        jj_consume_token(RBRACE);
        if (label == null || label.trim().length() == 0) node.setLabel(name);
        node.setProperty(property);
        nodeCache.put(name, node);
    }

    final public void Edge() throws ParseException {
        LinkedList parentList = new LinkedList();
        LinkedList nodeList = new LinkedList();
        List data = null;
        Token t;
        jj_consume_token(POTENTIAL);
        jj_consume_token(LPAREN);
        label_5:
        while (true) {
            t = jj_consume_token(IDENTIFIER);
            nodeList.add(t.image);
            switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
                case IDENTIFIER:
                    ;
                    break;
                default:
                    jj_la1[12] = jj_gen;
                    break label_5;
            }
        }
        switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
            case BIT_OR:
                jj_consume_token(BIT_OR);
                label_6:
                while (true) {
                    switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
                        case IDENTIFIER:
                            ;
                            break;
                        default:
                            jj_la1[13] = jj_gen;
                            break label_6;
                    }
                    t = jj_consume_token(IDENTIFIER);
                    parentList.add(t.image);
                }
                break;
            default:
                jj_la1[14] = jj_gen;
                ;
        }
        jj_consume_token(RPAREN);
        jj_consume_token(LBRACE);
        switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
            case DATA:
                jj_consume_token(DATA);
                jj_consume_token(ASSIGN);
                data = NestedNumberList();
                jj_consume_token(SEMICOLON);
                break;
            default:
                jj_la1[15] = jj_gen;
                ;
        }
        jj_consume_token(RBRACE);
        for (Iterator _i = nodeList.iterator(); _i.hasNext();) {
            Object nodeString = _i.next();
            if (edgeCache.get(nodeString) != null) {
                {
                    if (true) throw new RuntimeException("Duplicated data definition and parents of node " + nodeString);
                }
            }
            edgeCache.put(nodeString, new Object[]{parentList, data});
        }
    }

    final public LinkedList NestedNumberList() throws ParseException {
        LinkedList list = new LinkedList();
        List output = null;
        if (jj_2_1(2)) {
            output = NumberOrFuncList();
            list.addAll(output);
        } else if (jj_2_2(2)) {
            jj_consume_token(LPAREN);
            label_7:
            while (true) {
                output = NestedNumberList();
                list.add(output);
                switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
                    case LPAREN:
                        ;
                        break;
                    default:
                        jj_la1[16] = jj_gen;
                        break label_7;
                }
            }
            jj_consume_token(RPAREN);
        } else {
            jj_consume_token(-1);
            throw new ParseException();
        }
        {
            if (true) return list;
        }
        throw new Error("Missing return statement in function");
    }

    final public ASTExpr Expr() throws ParseException {
        ASTExpr e1 = null, e2 = null;
        e1 = MulDivExpr();
        label_8:
        while (true) {
            switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
                case PLUS:
                case MINUS:
                    ;
                    break;
                default:
                    jj_la1[17] = jj_gen;
                    break label_8;
            }
            switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
                case PLUS:
                    jj_consume_token(PLUS);
                    e2 = MulDivExpr();
                    e1 = new ASTAddExpr(e1, e2);
                    break;
                case MINUS:
                    jj_consume_token(MINUS);
                    e2 = MulDivExpr();
                    e1 = new ASTSubExpr(e1, e2);
                    break;
                default:
                    jj_la1[18] = jj_gen;
                    jj_consume_token(-1);
                    throw new ParseException();
            }
        }
        {
            if (true) return e1;
        }
        throw new Error("Missing return statement in function");
    }

    final public ASTExpr MulDivExpr() throws ParseException {
        ASTExpr e1 = null, e2 = null;
        e1 = PowExpr();
        label_9:
        while (true) {
            switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
                case STAR:
                case SLASH:
                    ;
                    break;
                default:
                    jj_la1[19] = jj_gen;
                    break label_9;
            }
            switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
                case STAR:
                    jj_consume_token(STAR);
                    e2 = PowExpr();
                    e1 = new ASTMulExpr(e1, e2);
                    break;
                case SLASH:
                    jj_consume_token(SLASH);
                    e2 = PowExpr();
                    e1 = new ASTDivExpr(e1, e2);
                    break;
                default:
                    jj_la1[20] = jj_gen;
                    jj_consume_token(-1);
                    throw new ParseException();
            }
        }
        {
            if (true) return e1;
        }
        throw new Error("Missing return statement in function");
    }

    final public ASTExpr PowExpr() throws ParseException {
        ASTExpr e1 = null, e2 = null;
        e1 = UnaryExpr();
        label_10:
        while (true) {
            switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
                case BIT_XOR:
                    ;
                    break;
                default:
                    jj_la1[21] = jj_gen;
                    break label_10;
            }
            jj_consume_token(BIT_XOR);
            e2 = UnaryExpr();
            e1 = new ASTPowExpr(e1, e2);
        }
        {
            if (true) return e1;
        }
        throw new Error("Missing return statement in function");
    }

    final public ASTExpr UnaryExpr() throws ParseException {
        ASTExpr e1 = null;
        Double d = null;
        Token t = null;
        switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
            case PLUS:
                jj_consume_token(PLUS);
                e1 = UnaryExpr();
                break;
            case MINUS:
                jj_consume_token(MINUS);
                e1 = UnaryExpr();
                e1 = new ASTNegExpr(e1);
                break;
            case LPAREN:
                jj_consume_token(LPAREN);
                e1 = Expr();
                jj_consume_token(RPAREN);
                break;
            case INTEGER_LITERAL:
            case FLOATING_POINT_LITERAL:
                d = NumberLiteral();
                e1 = new ASTLiteral(d);
                break;
            case IDENTIFIER:
                t = jj_consume_token(IDENTIFIER);
                e1 = new ASTVariable(t.image);
                break;
            default:
                jj_la1[22] = jj_gen;
                jj_consume_token(-1);
                throw new ParseException();
        }
        {
            if (true) return e1;
        }
        throw new Error("Missing return statement in function");
    }

    final public String StringLiteral() throws ParseException {
        Token t;
        t = jj_consume_token(STRING_LITERAL);
        {
            if (true) return t.image.substring(1, t.image.length() - 1);
        }
        throw new Error("Missing return statement in function");
    }

    final public LinkedList StringList() throws ParseException {
        LinkedList list = new LinkedList();
        String s;
        jj_consume_token(LPAREN);
        label_11:
        while (true) {
            switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
                case STRING_LITERAL:
                    ;
                    break;
                default:
                    jj_la1[23] = jj_gen;
                    break label_11;
            }
            s = StringLiteral();
            list.add(s);
        }
        jj_consume_token(RPAREN);
        {
            if (true) return list;
        }
        throw new Error("Missing return statement in function");
    }

    final public Double NumberLiteral() throws ParseException {
        Token t;
        switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
            case FLOATING_POINT_LITERAL:
                t = jj_consume_token(FLOATING_POINT_LITERAL);
                break;
            case INTEGER_LITERAL:
                t = jj_consume_token(INTEGER_LITERAL);
                break;
            default:
                jj_la1[24] = jj_gen;
                jj_consume_token(-1);
                throw new ParseException();
        }
        {
            if (true) return new Double(t.image);
        }
        throw new Error("Missing return statement in function");
    }

    final public LinkedList NumberOrFuncList() throws ParseException {
        LinkedList list = new LinkedList();
        Double number;
        ASTExpr e1, e2;
        int sgn = 1;
        jj_consume_token(LPAREN);
        label_12:
        while (true) {
            switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
                case NORMAL:
                case INTEGER_LITERAL:
                case FLOATING_POINT_LITERAL:
                case MINUS:
                    ;
                    break;
                default:
                    jj_la1[25] = jj_gen;
                    break label_12;
            }
            switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
                case INTEGER_LITERAL:
                case FLOATING_POINT_LITERAL:
                case MINUS:
                    switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
                        case MINUS:
                            jj_consume_token(MINUS);
                            sgn = -1;
                            break;
                        default:
                            jj_la1[26] = jj_gen;
                            ;
                    }
                    number = NumberLiteral();
                    list.add(new Double(sgn * number.doubleValue()));
                    sgn = 1;
                    break;
                case NORMAL:
                    jj_consume_token(NORMAL);
                    jj_consume_token(LPAREN);
                    e1 = Expr();
                    jj_consume_token(COMMA);
                    e2 = Expr();
                    jj_consume_token(RPAREN);
                    {
                        if (true) throw new RuntimeException("We don't know how to handle continuous nodes yet!");
                    }
                    break;
                default:
                    jj_la1[27] = jj_gen;
                    jj_consume_token(-1);
                    throw new ParseException();
            }
        }
        jj_consume_token(RPAREN);
        {
            if (true) return list;
        }
        throw new Error("Missing return statement in function");
    }

    final public LinkedList NumberList() throws ParseException {
        LinkedList list = new LinkedList();
        Double number;
        int sgn = 1;
        jj_consume_token(LPAREN);
        label_13:
        while (true) {
            switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
                case INTEGER_LITERAL:
                case FLOATING_POINT_LITERAL:
                case MINUS:
                    ;
                    break;
                default:
                    jj_la1[28] = jj_gen;
                    break label_13;
            }
            switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
                case MINUS:
                    jj_consume_token(MINUS);
                    sgn = -1;
                    break;
                default:
                    jj_la1[29] = jj_gen;
                    ;
            }
            number = NumberLiteral();
            list.add(new Double(sgn * number.doubleValue()));
            sgn = 1;
        }
        jj_consume_token(RPAREN);
        {
            if (true) return list;
        }
        throw new Error("Missing return statement in function");
    }

    final private boolean jj_2_1(int xla) {
        jj_la = xla;
        jj_lastpos = jj_scanpos = token;
        boolean retval = !jj_3_1();
        jj_save(0, xla);
        return retval;
    }

    final private boolean jj_2_2(int xla) {
        jj_la = xla;
        jj_lastpos = jj_scanpos = token;
        boolean retval = !jj_3_2();
        jj_save(1, xla);
        return retval;
    }

    final private boolean jj_3R_15() {
        if (jj_3R_17()) return true;
        if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
        return false;
    }

    final private boolean jj_3R_14() {
        if (jj_scan_token(LPAREN)) return true;
        if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
        Token xsp;
        while (true) {
            xsp = jj_scanpos;
            if (jj_3R_16()) {
                jj_scanpos = xsp;
                break;
            }
            if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
        }
        if (jj_scan_token(RPAREN)) return true;
        if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
        return false;
    }

    final private boolean jj_3R_23() {
        if (jj_scan_token(INTEGER_LITERAL)) return true;
        if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
        return false;
    }

    final private boolean jj_3_2() {
        if (jj_scan_token(LPAREN)) return true;
        if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
        Token xsp;
        if (jj_3R_15()) return true;
        if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
        while (true) {
            xsp = jj_scanpos;
            if (jj_3R_15()) {
                jj_scanpos = xsp;
                break;
            }
            if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
        }
        return false;
    }

    final private boolean jj_3_1() {
        if (jj_3R_14()) return true;
        if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
        return false;
    }

    final private boolean jj_3R_17() {
        Token xsp;
        xsp = jj_scanpos;
        if (jj_3_1()) {
            jj_scanpos = xsp;
            if (jj_3_2()) return true;
            if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
        } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
        return false;
    }

    final private boolean jj_3R_22() {
        if (jj_scan_token(FLOATING_POINT_LITERAL)) return true;
        if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
        return false;
    }

    final private boolean jj_3R_20() {
        if (jj_scan_token(MINUS)) return true;
        if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
        return false;
    }

    final private boolean jj_3R_19() {
        if (jj_scan_token(NORMAL)) return true;
        if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
        return false;
    }

    final private boolean jj_3R_21() {
        Token xsp;
        xsp = jj_scanpos;
        if (jj_3R_22()) {
            jj_scanpos = xsp;
            if (jj_3R_23()) return true;
            if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
        } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
        return false;
    }

    final private boolean jj_3R_18() {
        Token xsp;
        xsp = jj_scanpos;
        if (jj_3R_20())
            jj_scanpos = xsp;
        else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
        if (jj_3R_21()) return true;
        if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
        return false;
    }

    final private boolean jj_3R_16() {
        Token xsp;
        xsp = jj_scanpos;
        if (jj_3R_18()) {
            jj_scanpos = xsp;
            if (jj_3R_19()) return true;
            if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
        } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
        return false;
    }

    public NetParserTokenManager token_source;
    JavaCharStream jj_input_stream;
    public Token token, jj_nt;
    private int jj_ntk;
    private Token jj_scanpos, jj_lastpos;
    private int jj_la;
    public boolean lookingAhead = false;
    private boolean jj_semLA;
    private int jj_gen;
    final private int[] jj_la1 = new int[30];
    final private int[] jj_la1_0 = {0x600, 0x3601800, 0x3601800, 0x3601800, 0x3601800, 0x1c0000, 0x1c0000, 0x600000, 0x600000, 0x3000800, 0x80e000, 0x80e000, 0x0, 0x0, 0x0, 0x10000, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x44000000, 0x0, 0x44000000, 0x44020000, 0x0, 0x44020000, 0x44000000, 0x0, };
    final private int[] jj_la1_1 = {0x0, 0x0, 0x0, 0x0, 0x0, 0x100, 0x100, 0x0, 0x0, 0x0, 0x100, 0x100, 0x100, 0x100, 0x0, 0x0, 0x800, 0x0, 0x0, 0x0, 0x0, 0x0, 0x900, 0x2, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, };
    final private int[] jj_la1_2 = {0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x200, 0x0, 0x0, 0x30, 0x30, 0xc0, 0xc0, 0x400, 0x30, 0x0, 0x0, 0x20, 0x20, 0x20, 0x20, 0x20, };
    final private JJCalls[] jj_2_rtns = new JJCalls[2];
    private boolean jj_rescan = false;
    private int jj_gc = 0;

    public NetParser(java.io.InputStream stream) {
        jj_input_stream = new JavaCharStream(stream, 1, 1);
        token_source = new NetParserTokenManager(jj_input_stream);
        token = new Token();
        jj_ntk = -1;
        jj_gen = 0;
        for (int i = 0; i < 30; i++) jj_la1[i] = -1;
        for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();
    }

    public void ReInit(java.io.InputStream stream) {
        jj_input_stream.ReInit(stream, 1, 1);
        token_source.ReInit(jj_input_stream);
        token = new Token();
        jj_ntk = -1;
        jjtree.reset();
        jj_gen = 0;
        for (int i = 0; i < 30; i++) jj_la1[i] = -1;
        for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();
    }

    public NetParser(java.io.Reader stream) {
        jj_input_stream = new JavaCharStream(stream, 1, 1);
        token_source = new NetParserTokenManager(jj_input_stream);
        token = new Token();
        jj_ntk = -1;
        jj_gen = 0;
        for (int i = 0; i < 30; i++) jj_la1[i] = -1;
        for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();
    }

    public void ReInit(java.io.Reader stream) {
        jj_input_stream.ReInit(stream, 1, 1);
        token_source.ReInit(jj_input_stream);
        token = new Token();
        jj_ntk = -1;
        jjtree.reset();
        jj_gen = 0;
        for (int i = 0; i < 30; i++) jj_la1[i] = -1;
        for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();
    }

    public NetParser(NetParserTokenManager tm) {
        token_source = tm;
        token = new Token();
        jj_ntk = -1;
        jj_gen = 0;
        for (int i = 0; i < 30; i++) jj_la1[i] = -1;
        for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();
    }

    public void ReInit(NetParserTokenManager tm) {
        token_source = tm;
        token = new Token();
        jj_ntk = -1;
        jjtree.reset();
        jj_gen = 0;
        for (int i = 0; i < 30; i++) jj_la1[i] = -1;
        for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();
    }

    final private Token jj_consume_token(int kind) throws ParseException {
        Token oldToken;
        if ((oldToken = token).next != null)
            token = token.next;
        else
            token = token.next = token_source.getNextToken();
        jj_ntk = -1;
        if (token.kind == kind) {
            jj_gen++;
            if (++jj_gc > 100) {
                jj_gc = 0;
                for (int i = 0; i < jj_2_rtns.length; i++) {
                    JJCalls c = jj_2_rtns[i];
                    while (c != null) {
                        if (c.gen < jj_gen) c.first = null;
                        c = c.next;
                    }
                }
            }
            return token;
        }
        token = oldToken;
        jj_kind = kind;
        throw generateParseException();
    }

    final private boolean jj_scan_token(int kind) {
        if (jj_scanpos == jj_lastpos) {
            jj_la--;
            if (jj_scanpos.next == null) {
                jj_lastpos = jj_scanpos = jj_scanpos.next = token_source.getNextToken();
            } else {
                jj_lastpos = jj_scanpos = jj_scanpos.next;
            }
        } else {
            jj_scanpos = jj_scanpos.next;
        }
        if (jj_rescan) {
            int i = 0;
            Token tok = token;
            while (tok != null && tok != jj_scanpos) {
                i++;
                tok = tok.next;
            }
            if (tok != null) jj_add_error_token(kind, i);
        }
        return (jj_scanpos.kind != kind);
    }

    final public Token getNextToken() {
        if (token.next != null)
            token = token.next;
        else
            token = token.next = token_source.getNextToken();
        jj_ntk = -1;
        jj_gen++;
        return token;
    }

    final public Token getToken(int index) {
        Token t = lookingAhead ? jj_scanpos : token;
        for (int i = 0; i < index; i++) {
            if (t.next != null)
                t = t.next;
            else
                t = t.next = token_source.getNextToken();
        }
        return t;
    }

    final private int jj_ntk() {
        if ((jj_nt = token.next) == null)
            return (jj_ntk = (token.next = token_source.getNextToken()).kind);
        else
            return (jj_ntk = jj_nt.kind);
    }

    private java.util.Vector jj_expentries = new java.util.Vector();
    private int[] jj_expentry;
    private int jj_kind = -1;
    private int[] jj_lasttokens = new int[100];
    private int jj_endpos;

    private void jj_add_error_token(int kind, int pos) {
        if (pos >= 100) return;
        if (pos == jj_endpos + 1) {
            jj_lasttokens[jj_endpos++] = kind;
        } else if (jj_endpos != 0) {
            jj_expentry = new int[jj_endpos];
            for (int i = 0; i < jj_endpos; i++) {
                jj_expentry[i] = jj_lasttokens[i];
            }
            boolean exists = false;
            for (java.util.Enumeration e = jj_expentries.elements(); e.hasMoreElements();) {
                int[] oldentry = (int[]) (e.nextElement());
                if (oldentry.length == jj_expentry.length) {
                    exists = true;
                    for (int i = 0; i < jj_expentry.length; i++) {
                        if (oldentry[i] != jj_expentry[i]) {
                            exists = false;
                            break;
                        }
                    }
                    if (exists) break;
                }
            }
            if (!exists) jj_expentries.addElement(jj_expentry);
            if (pos != 0) jj_lasttokens[(jj_endpos = pos) - 1] = kind;
        }
    }

    final public ParseException generateParseException() {
        jj_expentries.removeAllElements();
        boolean[] la1tokens = new boolean[91];
        for (int i = 0; i < 91; i++) {
            la1tokens[i] = false;
        }
        if (jj_kind >= 0) {
            la1tokens[jj_kind] = true;
            jj_kind = -1;
        }
        for (int i = 0; i < 30; i++) {
            if (jj_la1[i] == jj_gen) {
                for (int j = 0; j < 32; j++) {
                    if ((jj_la1_0[i] & (1 << j)) != 0) {
                        la1tokens[j] = true;
                    }
                    if ((jj_la1_1[i] & (1 << j)) != 0) {
                        la1tokens[32 + j] = true;
                    }
                    if ((jj_la1_2[i] & (1 << j)) != 0) {
                        la1tokens[64 + j] = true;
                    }
                }
            }
        }
        for (int i = 0; i < 91; i++) {
            if (la1tokens[i]) {
                jj_expentry = new int[1];
                jj_expentry[0] = i;
                jj_expentries.addElement(jj_expentry);
            }
        }
        jj_endpos = 0;
        jj_rescan_token();
        jj_add_error_token(0, 0);
        int[][] exptokseq = new int[jj_expentries.size()][];
        for (int i = 0; i < jj_expentries.size(); i++) {
            exptokseq[i] = (int[]) jj_expentries.elementAt(i);
        }
        return new ParseException(token, exptokseq, tokenImage);
    }

    final public void enable_tracing() {
    }

    final public void disable_tracing() {
    }

    final private void jj_rescan_token() {
        jj_rescan = true;
        for (int i = 0; i < 2; i++) {
            JJCalls p = jj_2_rtns[i];
            do {
                if (p.gen > jj_gen) {
                    jj_la = p.arg;
                    jj_lastpos = jj_scanpos = p.first;
                    switch (i) {
                        case 0:
                            jj_3_1();
                            break;
                        case 1:
                            jj_3_2();
                            break;
                    }
                }
                p = p.next;
            } while (p != null);
        }
        jj_rescan = false;
    }

    final private void jj_save(int index, int xla) {
        JJCalls p = jj_2_rtns[index];
        while (p.gen > jj_gen) {
            if (p.next == null) {
                p = p.next = new JJCalls();
                break;
            }
            p = p.next;
        }
        p.gen = jj_gen + xla - jj_la;
        p.first = token;
        p.arg = xla;
    }

    static final class JJCalls {
        int gen;
        Token first;
        int arg;
        JJCalls next;
    }

}
